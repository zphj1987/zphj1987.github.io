<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[zphj1987]]></title>
  <link href="zphj1987.com/atom.xml" rel="self"/>
  <link href="zphj1987.com/"/>
  <updated>2022-10-17T16:09:17+08:00</updated>
  <id>zphj1987.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[rock5b可以运行的UOS操作系统]]></title>
    <link href="zphj1987.com/rock5b-ke-yi-yun-xing-deuos-ca.html"/>
    <updated>2022-10-17T15:13:28+08:00</updated>
    <id>zphj1987.com/rock5b-ke-yi-yun-xing-deuos-ca.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>uos是国产操作系统里面桌面做的顶尖的操作系统了，前身是deepin，基于的是debian，ubuntu系的做的桌面，国产操作系统的优势是会做一些办公工具相关的适配</p>
<p>查了下资料，pro版本的试用期是90天，没有授权的话，只是不能使用应用商店，其它的使用没有区别</p>
<h2><a id="%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关资源</h2>
<p>这个img为初始的版本，比较大，有12G的，看了下内部装完系统占用有7G左右，这个大小方面和使用后续会持续发布新的版本，内核相关的后面看下是否也更新替换下，目前采用的是官方提供的</p>
<h2><a id="%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用</h2>
<p>由于网盘的原因，采用的分卷压缩的，全部分卷下载完成后，使用360zip进行解压即可</p>
<span id="more"></span><!-- more -->
<h3><a id="%E7%99%BB%E9%99%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>登陆</h3>
<p>用户名密码：<br />
root<br />
123456</p>
<p>默认为命令行界面，执行下startx即可进入桌面</p>
<p>这个地方有个问题，设置为图形界面启动后，tty1会成为日志输出，tty2才可以登陆，设置文本登陆，然后再执行startx即可<br />
<img src="media/16659908084571/16659915417239.jpg" alt="" /></p>
<p>登陆以后</p>
<p><img src="media/16659908084571/16659941281094.jpg" alt="" /></p>
<h2><a id="%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>版本发布说明</h2>
<p>rock-5b-uos-202210171400<br />
发布说明：<br />
初始版本，可以使用<br />
资源地址：<br />
链接: <a href="https://pan.baidu.com/s/1W-FwrCBzPAh3Ty4HrcX1Fw?pwd=3vmj">https://pan.baidu.com/s/1W-FwrCBzPAh3Ty4HrcX1Fw?pwd=3vmj</a> 提取码: 3vmj</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[opencloudos aarch64可以使用的vdbench]]></title>
    <link href="zphj1987.com/opencloudos-aarch64ke-yi-shi-y.html"/>
    <updated>2022-10-10T15:35:47+08:00</updated>
    <id>zphj1987.com/opencloudos-aarch64ke-yi-shi-y.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>vdbench是一个I/O工作负载生成器，通常用于验证数据完整性和测试存储性能。它可以运行在windows、linux环境，可用于测试文件系统或块设备基准性能。很多大型的测试都是采用这个工具进行测试的，能过模拟很多不同的负载</p>
<p>vdbench采用java编写的，能够比较好的支持跨平台，但是内部引用的库是会挑系统平台的，默认的zip包里面就没有带aarch64的库，需要自己获取源码，然后在aarch64上编译库文件，然后再放到zip包里面，本篇结尾的资源就是提供的这个包</p>
<h2><a id="%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题现象</h2>
<h3><a id="%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E8%BD%AF%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装基本软件</h3>
<pre><code class="language-bash">yum install java-1.8.0-openjdk
</code></pre>
<h3><a id="%E8%A7%A3%E5%8E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解压</h3>
<pre><code class="language-bash">unzip vdbench50407.zip -d vdbench50407
</code></pre>
<span id="more"></span><!-- more -->
<h3><a id="%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>执行测试</h3>
<pre><code class="language-bash">[root@172 ~]# ./vdbench50407/vdbench -t


Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
Vdbench distribution: vdbench50407 Tue June 05  9:49:29 MDT 2018
For documentation, see 'vdbench.pdf'.

08:17:47.598 Created output directory '/root/output'
08:17:47.653 input argument scanned: '-f/tmp/parmfile'
08:17:47.690 Starting slave: /root/vdbench50407/vdbench SlaveJvm -m localhost -n localhost-10-220930-08.17.47.589 -l localhost-0 -p 5570
08:17:47.716
08:17:47.716 File /root/vdbench50407/linux/aarch64.so does not exist.
08:17:47.716 This may be an OS that a shared library currently
08:17:47.716 is not available for. You may have to do your own compile.
08:17:47.716 t: java.lang.UnsatisfiedLinkError: Can't load library: /root/vdbench50407/linux/aarch64.so
08:17:47.716
08:17:47.716 Loading of shared library /root/vdbench50407/linux/aarch64.so failed.
08:17:47.716 There may be issues related to a cpu type not being
08:17:47.716 acceptable to Vdbench, e.g. MAC PPC vs. X86
08:17:47.716 Contact me at the Oracle Vdbench Forum for support.
08:17:47.716
08:17:48.219
08:17:48.219 Failure loading shared library
</code></pre>
<p>可以看到关键的信息</p>
<pre><code class="language-bash">Can't load library: /root/vdbench50407/linux/aarch64.so
</code></pre>
<p>这个就是缺少的库文件</p>
<h2><a id="%E4%BD%BF%E7%94%A8%E4%BF%AE%E6%94%B9%E5%A5%BD%E7%9A%84%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用修改好的包</h2>
<h3><a id="%E8%A7%A3%E5%8E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解压</h3>
<pre><code class="language-bash">[root@172 ~]# unzip vdbench50407-opencloudos-aarch64.zip
</code></pre>
<h3><a id="%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>执行测试</h3>
<pre><code class="language-bash">[root@172 ~]# ./vdbench50407/vdbench -t


Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
Vdbench distribution: vdbench50407 Tue June 05  9:49:29 MDT 2018
For documentation, see 'vdbench.pdf'.

08:19:32.437 input argument scanned: '-f/tmp/parmfile'
08:19:32.475 Starting slave: /root/vdbench50407/vdbench SlaveJvm -m localhost -n localhost-10-220930-08.19.32.370 -l localhost-0 -p 5570
08:19:32.676 All slaves are now connected
08:19:34.003 Starting RD=rd1; I/O rate: 100; elapsed=5; For loops: None

Sep 30, 2022    interval        i/o   MB/sec   bytes   read     resp     read    write     read    write     resp  queue  cpu%  cpu%
                               rate  1024**2     i/o    pct     time     resp     resp      max      max   stddev  depth sys+u   sys
08:19:35.102           1       67.0     0.07    1024  47.76    0.074    0.058    0.088     0.12     0.29    0.048    0.0  17.1   4.7
08:19:36.013           2      110.0     0.11    1024  55.45    0.046    0.037    0.056     0.09     0.15    0.026    0.0  11.5   1.0
08:19:37.011           3       91.0     0.09    1024  47.25    0.069    0.054    0.083     0.11     0.15    0.033    0.0   9.0   1.0
08:19:38.010           4      108.0     0.11    1024  51.85    0.061    0.046    0.077     0.15     0.74    0.072    0.0   7.1   2.0
08:19:39.026           5       90.0     0.09    1024  57.78    0.062    0.051    0.076     0.22     0.30    0.042    0.0   7.1   1.0
08:19:39.058     avg_2-5       99.8     0.10    1024  53.13    0.059    0.046    0.073     0.22     0.74    0.048    0.0   8.6   1.3
08:19:39.849 Vdbench execution completed successfully. Output directory: /root/output
</code></pre>
<p>可以看到可以正常运行了</p>
<h2><a id="%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>资源地址</h2>
<p>vdbench50407-opencloudos-aarch64.zip下载地址：</p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1YdPWJnhdl3XTZZIhAX6NIA?pwd=gwm3">https://pan.baidu.com/s/1YdPWJnhdl3XTZZIhAX6NIA?pwd=gwm3</a> 提取码: gwm3</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vdbench测试生成器]]></title>
    <link href="zphj1987.com/vdbench-ce-shi-sheng-cheng-qi.html"/>
    <updated>2022-10-09T10:25:04+08:00</updated>
    <id>zphj1987.com/vdbench-ce-shi-sheng-cheng-qi.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%83%8C%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>背景</h2>
<p>vdbench测试是根据配置文件进行测试的，有的时候我们需要循环的进行不同的测试用例进行测试，并且进行数据的大量填充，大小文件进行交错的填充来检测环境的稳定性</p>
<h2><a id="%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分析</h2>
<p>我们定义几组不同的配置文件，然后根据配置文件定义测试的次数，然后定义总次数，以及测试目录，然后生成配置文件，再使用脚本按顺序进行测试并记录结果</p>
<h2><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h2>
<h3><a id="%E5%86%99%E5%87%A0%E4%B8%AA%E6%A8%A1%E7%89%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>写几个模版配置文件</h3>
<p>这个没有什么特殊的地方，根据自己的需要编写即可<br />
测试的目录留空</p>
<pre><code class="language-bash">anchor=
</code></pre>
<h3><a id="%E7%BC%96%E5%86%99run-ini%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编写run.ini配置文件</h3>
<p>安装解析ini的软件</p>
<pre><code class="language-bash">yum install crudini
</code></pre>
<span id="more"></span><!-- more -->
<p>这个是用于定义上面配置文件的运行组合的</p>
<pre><code class="language-bash">[runcase]
run1=base-big-1M
run2=base-mid-500K
run3=base-small-100K
[runtime]
run1=1
run2=2
run3=1
total=8
[rundir]
rundir=/mnt
</code></pre>
<h3><a id="%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生成测试配置文件</h3>
<pre><code class="language-bash">#! /bin/sh
unalias cp
i=0
rundir=`crudini --get run.ini rundir rundir`
total=`crudini --get run.ini runtime total`
while (( total &gt; 0 ))
do
    #echo $num
    for runcase in `crudini --get run.ini runcase`
    do
        runtime=`crudini --get run.ini runtime $runcase`
        for run in  `seq $runtime`
        do   
            i=$(( $i + 1 ))
            #echo $run
            myrun=`crudini --get run.ini runcase $runcase`
            mytest=$myrun-$i
            echo $mytest
            mkdir runcase/$mytest -p
            total=$(( $total - 1 ))
            cp -ra $myrun runcase/$mytest/case.conf
            sed -i &quot;s#anchor=*,#anchor=${rundir}/${mytest},#&quot; runcase/$mytest/case.conf
        done
    done

done
</code></pre>
<h3><a id="%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行测试</h3>
<pre><code class="language-bash">#! /bin/sh
vdbench=/root/vdbench50407/vdbench
unalias cp
i=0
rundir=`crudini --get run.ini rundir rundir`
total=`crudini --get run.ini runtime total`
while (( total &gt; 0 ))
do
    #echo $num
    for runcase in `crudini --get run.ini runcase`
    do
        runtime=`crudini --get run.ini runtime $runcase`
        for run in  `seq $runtime`
        do   
            i=$(( $i + 1 ))
            #echo $run
            myrun=`crudini --get run.ini runcase $runcase`
            mytest=$myrun-$i
            echo $mytest
            total=$(( $total - 1 ))
            dofile=runcase/$mytest/dodo
            if [ ! -f &quot;$dofile&quot; ]; then
                $vdbench -f runcase/$mytest/case.conf -o runcase/$mytest/output
                touch runcase/$mytest/dodo
            fi
        done
    done

done
</code></pre>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>使用脚本就控制几个循环的执行，可以自定义不同的vdbench怎么去跑的，整体上操作难度较低，测试结果也分开保存了，数据也写到不同的目录</p>
<h2><a id="%E5%BD%92%E6%A1%A3%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>归档项目地址</h2>
<blockquote>
<p><a href="https://e.coding.net/zphj1987/vdbench-generater/vdbench-generater.git">https://e.coding.net/zphj1987/vdbench-generater/vdbench-generater.git</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[opencloudos容器镜像优化]]></title>
    <link href="zphj1987.com/opencloudos-rong-qi-jing-xiang.html"/>
    <updated>2022-09-28T22:53:25+08:00</updated>
    <id>zphj1987.com/opencloudos-rong-qi-jing-xiang.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>目前因为官方的容器也在移植阶段，并且系统是刚出来的，各方面的应该都会慢慢完善，因为之前也做了相关的移植，所以移植的作为备选的即可</p>
<p>测试发现官方的容器目前还有一些需要处理一些东西，本篇就是简单的介绍怎么用官方的容器，以及存在的问题，最后提供下我自己移植好的容器</p>
<h2><a id="%E5%AE%98%E6%96%B9%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>官方容器使用方法</h2>
<h3><a id="%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拉取镜像</h3>
<p>这个操作是使用容器的常规操作了，官方也都发布到了docker hub里面，直接拉取即可</p>
<pre><code class="language-bash">[root@lab101 /]# docker pull opencloudos/opencloudos:8.6
[root@lab101 /]# docker image ls
docker.io/opencloudos/opencloudos   8.6                 85381566b97e        7 days ago               280 MB
</code></pre>
<p>可以看到官方的为280MB</p>
<span id="more"></span><!-- more -->
<h3><a id="%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>启动容器</h3>
<pre><code class="language-bash">[root@lab101 /]# docker run --name opencloudos  --net=host  --hostname=opencloudos  -dit   --privileged=true  opencloudos/opencloudos:8.6   /sbin/init
bbe06493e7b2305b430c635c23b06b6eeca7d0df38ebfa6a9ab8428a39f1b11c
</code></pre>
<h3><a id="%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进入容器</h3>
<pre><code class="language-bash">[root@lab101 /]# docker exec -it opencloudos /bin/bash
bash-4.4#
</code></pre>
<p>可以看到进入容器是显示的bash-4.4不是主机名<br />
可以看到</p>
<pre><code class="language-bash">bash-4.4# ls /root/
</code></pre>
<p>root下面是空的<br />
应该是要有下面的</p>
<pre><code class="language-bash">[root@centos8 /]# ls /root/.
./             ../            .bash_history  .bash_logout   .bash_profile  .bashrc        .cshrc         .tcshrc
</code></pre>
<p>检查常用包</p>
<pre><code class="language-bash">bash-4.4# rpm -qa|grep hostname
bash-4.4# rpm -qa|grep vi
device-mapper-1.02.181-3.oc8.x86_64
device-mapper-libs-1.02.181-3.oc8.x86_64
</code></pre>
<p>发现vi和hostname命令都没加进去，这里基本的包还是保持比较好，这个在centos8的官方容器里面都做了保留</p>
<p>上面的主机名的处理也可以自己修改/root/.下面做处理做恢复，相关的包也可以自己安装下即可</p>
<h2><a id="%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化</h2>
<p>基于官方容器的优化，这个实际上我是基于操作系统，然后按centos8的容器包的标准，以及根据centos8的裁剪力度，来做的容器包</p>
<pre><code class="language-bash">[root@lab101 /]# docker pull zphj1987/opencloudos:8.6
</code></pre>
<p>使用上面的就可以拿到opencloudos的8.6的容器版本，容器大小做到了跟官方的centos8基本一致的大小</p>
<pre><code class="language-bash">[root@lab101 /]# docker pull zphj1987/opencloudos:8.6
Trying to pull repository docker.io/zphj1987/opencloudos ...
8.6: Pulling from docker.io/zphj1987/opencloudos
e6ad0a38566d: Downloading [&gt;                                                  ] 528.9 kB/87.57 MB
</code></pre>
<p>容器iamge大小</p>
<pre><code class="language-bash">[root@opencloud ~]# docker image ls
zphj1987/opencloudos   8.6              8779b4d2cd5c   5 hours ago     227MB
</code></pre>
<p>基本跟centos官方的 231 MB大小一致</p>
<h3><a id="%E5%81%9A%E5%AE%B9%E5%99%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%8F%E9%AA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>做容器过程的一个经验</h3>
<p>如果改了容器，不要在原来的基础上面commit,直接export出来，然后创建成新的容器，这样是一个比较简单的控制容器大小的方法，一直commit会叠加容器的大小</p>
<h2><a id="%E5%AF%B9%E5%BE%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对待问题的方法</h2>
<ul>
<li>发现问题</li>
<li>提出方案</li>
<li>解决问题</li>
</ul>
<h2><a id="%E5%8F%8D%E9%A6%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>反馈</h2>
<p>如果有技术问题可以联系：</p>
<ul>
<li><a href="mailto:zphj1987@gmail.com">zphj1987@gmail.com</a></li>
</ul>
<h2><a id="%E5%BC%80%E6%BA%90%E6%91%98%E6%98%9F%E8%AE%A1%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开源摘星计划</h2>
<p>本文已参与「开源摘星计划」，欢迎正在阅读的你加入。活动链接：<a href="https://github.com/weopenprojects/WeOpen-Star">https://github.com/weopenprojects/WeOpen-Star</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[脚本禁止登录尝试]]></title>
    <link href="zphj1987.com/jiao-ben-jin-zhi-deng-lu-chang.html"/>
    <updated>2022-09-22T17:47:12+08:00</updated>
    <id>zphj1987.com/jiao-ben-jin-zhi-deng-lu-chang.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%9C%80%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求</h2>
<p>有ip不停的尝试登录，可以通过防火墙进行屏蔽</p>
<span id="more"></span><!-- more -->
<h2><a id="%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脚本</h2>
<pre><code class="language-bash">cat /var/log/secure |grep failure|awk '{for (i=1;i&lt;=NF;i++){if ($i ~/rhost/) {print $i}}}'| sort | uniq|awk -F&quot;=&quot; '{print $2}' &gt;&gt; black.list

cat black.list|sort|uniq &gt; black.list.tmp
rm -rf black.list
mv black.list.tmp black.list

firewall-cmd --list-rich-rules &gt; blackiprule.list
all=`cat blackiprule.list`

for ip in `cat black.list|sort|uniq`
do
if [[ $all =~ $ip ]]
then
:
else
	echo &quot;不包含&quot;
	firewall-cmd --permanent --add-rich-rule=&quot;rule family='ipv4' source address='$ip' reject&quot;
fi
done

cat blackiprule.list|wc -l
firewall-cmd --reload
</code></pre>
<p>定期执行脚本即可</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gluster副本三配置down两个可写]]></title>
    <link href="zphj1987.com/gluster-fu-ben-san-pei-zhidown.html"/>
    <updated>2022-09-22T17:24:29+08:00</updated>
    <id>zphj1987.com/gluster-fu-ben-san-pei-zhidown.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%9C%80%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求</h2>
<p>默认做了控制，副本三down两个就阻止写了，这个可以通过参数控制</p>
<h2><a id="%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数调整</h2>
<p>副本三，关闭两个可写</p>
<pre><code class="language-bash">gluster volume set testvolume cluster.quorum-type fixed
gluster volume set testvolume cluster.quorum-count 1
gluster volume set testvolume cluster.quorum-reads yes
gluster volume set  testvolume network.ping-timeout 10
</code></pre>
<span id="more"></span><!-- more -->
<p>副本二，关闭一个可写</p>
<pre><code class="language-bash">gluster volume set testvolume cluster.quorum-count 1
gluster volume set testvolume cluster.quorum-reads yes
gluster volume set  testvolume network.ping-timeout 10
</code></pre>
<p>上面的区别是，副本3默认把cluster.quorum-type设置为auto了</p>
<h2><a id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考资料</h2>
<p><a href="https://docs.gluster.org/en/latest/Administrator-Guide/arbiter-volumes-and-quorum/">Arbiter volumes and quorum options in gluster</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MAC M1可以运行的opencloudos 8.6]]></title>
    <link href="zphj1987.com/mac-m1ke-yi-yun-xing-deopenclo.html"/>
    <updated>2022-09-16T18:04:45+08:00</updated>
    <id>zphj1987.com/mac-m1ke-yi-yun-xing-deopenclo.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>在centos7比较晚的版本，以及centos8的aarch64的版本里面，内核的pagesize已经默认改成了64K，而mac M1的操作系统底层最大支持的pagesize是16K的，所以启动系统的时候，安装就直接闪退</p>
<p><img src="media/16633226856220/16633228021078.jpg" alt="" /></p>
<p>显示是上面的效果，这个在centos系统里面都有这个问题，fedora里面就还是维持4k，没有问题</p>
<span id="more"></span><!-- more -->
<h2><a id="%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题分析</h2>
<p>操作系统安装的时候会加载一个内核，这个地方需要修改的地方</p>
<ul>
<li>initrd.gz</li>
<li>vmlinuz<br />
这两个需要修改为4K的</li>
</ul>
<p>然后加载安装的时候，会加载install.img，这个里面带的是系统安装过程需要的内核模块，所以这个地方也需要替换</p>
<p>进入安装系统以后，安装的内核rpm包也是64k的，那么也需要把这个地方替换掉</p>
<p>上面的步骤完成以后，打的新的iso 就是可以正常在M1下运行的ISO了</p>
<p><img src="media/16633226856220/16633230068670.jpg" alt="" /><br />
<img src="media/16633226856220/16633239872905.jpg" alt="" /></p>
<h2><a id="%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>说明</h2>
<p>M1是aarch64架构的，可以使用vmware fusion 做虚拟机，这个是免费的，不用购买pd来做，那么这个M1的架构有什么好处，就是如果在做国产化或者arm的适配的时候，有一个高性能的虚拟机会方便的很多，比如需要对opencloudos进行arm的其它包的开发的时候，如果物理机器资源不是那么充足的情况下，就可以独立在虚拟机里面完成适配，目前看就是这个pagesize影响了安装，其它的ubuntu，centos，也都做了定制ISO进行了发布</p>
<p>安装部分内核调用了fedora的一部分东西，所以分区如果不喜欢看到fedora字样，可以不用lvm分区即可，不过这个本身是虚拟机，问题不大，ISO其它部分没有做任何改动</p>
<h2><a id="%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>资源地址</h2>
<p>链接: <a href="https://pan.baidu.com/s/1-UBAAco0GQTDKLrQtl8IMA?pwd=x9bp">https://pan.baidu.com/s/1-UBAAco0GQTDKLrQtl8IMA?pwd=x9bp</a> 提取码: x9bp</p>
<h2><a id="%E5%BC%80%E6%BA%90%E6%91%98%E6%98%9F%E8%AE%A1%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开源摘星计划</h2>
<p>本文已参与「开源摘星计划」，欢迎正在阅读的你加入。活动链接：<a href="https://github.com/weopenprojects/WeOpen-Star">https://github.com/weopenprojects/WeOpen-Star</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[端口转发配置]]></title>
    <link href="zphj1987.com/duan-kou-zhuan-fa-pei-zhi-xu-q.html"/>
    <updated>2022-09-16T12:18:22+08:00</updated>
    <id>zphj1987.com/duan-kou-zhuan-fa-pei-zhi-xu-q.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%9C%80%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求</h2>
<p>有的时候机器有一台网关机器，需要做端口转发的工作，那么可以使用iptables或者使用firwalld进行配置，firewalld底层也是调用的跟iptables一样的内核模块的，只是命令的不同</p>
<span id="more"></span><!-- more -->
<h2><a id="%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置</h2>
<h3><a id="%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>环境说明</h3>
<p><img src="media/16633019023390/16633021891118.jpg" alt="" /></p>
<ul>
<li>
<p>机器A</p>
<ul>
<li>外网IP：192.168.0.85</li>
<li>内网IP：192.168.1.103</li>
</ul>
</li>
<li>
<p>机器B</p>
<ul>
<li>内网IP：192.168.1.102</li>
</ul>
</li>
<li>
<p>机器C</p>
<ul>
<li>内网IP：192.168.1.101</li>
</ul>
</li>
</ul>
<p>配置访问192.168.0.85端口44561映射到192.168.1.102的4456端口<br />
配置访问192.168.0.85端口44562映射到192.168.1.101的4456端口</p>
<h3><a id="%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通用配置</h3>
<p>开启内核转发功能</p>
<pre><code class="language-bash">[root@lab103 ~]# cat /etc/sysctl.conf |grep forwa
net.ipv4.ip_forward = 1
[root@lab103 ~]# sysctl -p
</code></pre>
<h3><a id="%E4%BD%BF%E7%94%A8iptable%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用iptable配置</h3>
<pre><code class="language-bash">#!/bin/sh
IPT=&quot;/sbin/iptables&quot;
/bin/echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward
/sbin/modprobe ip_tables
/sbin/modprobe iptable_filter
/sbin/modprobe iptable_nat
/sbin/modprobe ip_conntrack
/sbin/modprobe ip_conntrack_ftp
/sbin/modprobe ip_nat_ftp
$IPT -F
$IPT -t nat -F
$IPT -X
$IPT -t nat -X
$IPT -Z
$IPT -t nat -Z
iptables -t filter -P FORWARD  ACCEPT
#DNAT 做端口转发 lab102
$IPT -t nat -A PREROUTING -d 192.168.0.85 -p tcp --dport 44561 -j DNAT --to-destination 192.168.1.102:4456
#SNAT 做端口转发
$IPT -t nat -A POSTROUTING -p tcp -d 192.168.1.102 --dport 4456 -j SNAT --to-source 192.168.1.103


#DNAT 做端口转发 lab1021
$IPT -t nat -A PREROUTING -d 192.168.0.85 -p tcp --dport 44562 -j DNAT --to-destination 192.168.1.101:4456
#SNAT 做端口转发
$IPT -t nat -A POSTROUTING -p tcp -d 192.168.1.101 --dport 4456 -j SNAT --to-source 192.168.1.103
</code></pre>
<p>上面的注意下那个to-source后面应该接上转发机器的内网的IP的地址，如果错了就有问题</p>
<h3><a id="%E4%BD%BF%E7%94%A8firewalld%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用firewalld配置</h3>
<pre><code class="language-bash">#!/bin/sh
firewall-cmd --add-masquerade --permanent
firewall-cmd --add-port=44561/tcp --permanent
firewall-cmd --add-port=44562/tcp --permanent
firewall-cmd --add-forward-port=port=44561:proto=tcp:toport=4456:toaddr=192.168.1.102 --permanent
firewall-cmd --add-forward-port=port=44562:proto=tcp:toport=4456:toaddr=192.168.1.101 --permanent
firewall-cmd --reload
firewall-cmd --list-all
</code></pre>
<h2><a id="%E6%B3%A8%E6%84%8F%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注意点</h2>
<p>上面的配置好转发以后都不要在转发的机器本机进行测试，本机上直接测试会不通，这个需要在外部进行访问转发机器进行验证</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[获取一段时间内ceph osd的磁盘读写情况]]></title>
    <link href="zphj1987.com/huo-qu-yi-duan-shi-jian-neicep.html"/>
    <updated>2022-09-09T11:48:21+08:00</updated>
    <id>zphj1987.com/huo-qu-yi-duan-shi-jian-neicep.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%9C%80%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求</h2>
<p>这个是统计一段时间内ceph的磁盘上的数据的读取和写入的数据量以及花费的时间</p>
<span id="more"></span><!-- more -->
<h2><a id="%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>信息获取</h2>
<pre><code class="language-bash">[root@node235 ceph]# cat /sys/block/sdj/sdj1/stat
    1575        0   335680     1687   145461       46  5334992   269147        0    54562   270566

第一个域 读取磁盘的次数
第二个是 合并读取的次数
第三个域 读扇区的次数
第四个域 读花费的毫秒数
第五个域 写完成次数
第六个域 合并写次数
第七个域 写扇区的次数
第八个域 写操作花的毫秒数
第九个域 正在处理的io数目
第十个域 输入输出花的总毫秒数
第十一个域 输入输出花的加权毫秒数
</code></pre>
<p>来源：</p>
<blockquote>
<p><a href="https://www.kernel.org/doc/html/v5.3/admin-guide/iostats.html">https://www.kernel.org/doc/html/v5.3/admin-guide/iostats.html</a></p>
</blockquote>
<h2><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h2>
<pre><code class="language-bash">[root@node235 ceph]# cat getread.sh 
[root@node235 ceph]# cat getread.sh 
#! /bin/bash
IFS=$'\n\n' 
for osd in `ceph osd dump|grep osd|grep -v req|grep -v max|awk '{print ``1,``19}'`
do 
osdnum=`echo  $osd|awk '{print $1}'`
osdid=`echo  $osd|awk '{print $2}'`
vgname=`lvdisplay |grep $osdid -A 1|tail  -n 1|awk '{print $3}'`
pvname=`pvdisplay |grep $vgname -B1|head -n 1|awk '{print $3}'`

diskname=`echo ${pvname%?}|cut -d / -f 3`
pvpath=`echo $pvname|cut -d / -f 3`
readsec=`cat /sys/block/``diskname/``pvpath/stat|awk '{print $3}'`
readmb=`expr $readsec \* 512 / 1024 / 1024`
readtime=`cat /sys/block/``diskname/``pvpath/stat|awk '{print $4}'`
readtimesec=`expr $readtime / 1000`
writesec=`cat /sys/block/``diskname/``pvpath/stat|awk '{print $7}'`
writemb=`expr $writesec \* 512 / 1024 / 1024`
writetime=`cat /sys/block/``diskname/``pvpath/stat|awk '{print $8}'`
writetimesec=`expr $writetime / 1000`
echo  $osdnum  $osdid  $vgname  $pvname  $readmb $readtimesec $writemb $writetimesec

done


</code></pre>
<h2><a id="%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>效果</h2>
<pre><code class="language-bash">[root@node235 ceph]# bash getread.sh 
osd.0 f6203dc0-7007-42da-bb1b-6ac54a9f9f74 ceph-36597766-1058-490f-bb46-ae4fd8eb141a /dev/sdd1 10063 86 13 0
osd.1 c4b7f141-51a0-4b97-80b5-e9681025f7db ceph-f786b5a2-82f4-4086-b0d1-7f5e6787c421 /dev/sdc1 320 1 1606 174
osd.2 24f68dd2-5a4f-4b41-8775-ae0211a06e5d ceph-07e22954-93d0-4bb1-9ce3-59485eab1673 /dev/sdi1 249 1 1604 155
osd.3 deed6a2e-456f-40be-bade-07a4b358e2c1 ceph-f1f76e61-d0d6-447b-ac26-a9a2d7fd2d5d /dev/sds1 320 1 1606 169
osd.4 f325a546-a6c7-4610-9916-31062ec6decc ceph-5c1357a5-036a-4f2e-83a8-4463e4349264 /dev/sdf1 320 2 1606 162
osd.5 3790748f-f212-4d46-8b72-b6c9ba007019 ceph-9874a1ac-9163-4936-a2f9-976260f19d6d /dev/sdr1 321 1 1606 165
osd.6 50140786-a01d-47c4-bca4-68ad7730863c ceph-0e4af92c-9766-467c-a7d5-db4435aadd6b /dev/sdk1 243 1 1604 149
osd.7 5e56f9a0-7637-477a-95cf-b995987e6270 ceph-c0de6d4b-1907-49d7-aa9b-194ccbc72465 /dev/sdb1 321 2 1606 172
osd.8 261ea9d8-581b-42ec-9493-1df7b74394b7 ceph-54946fde-edc4-4cf1-b59a-375d69bfff7a /dev/sdm1 237 1 1604 149
osd.9 a4212438-e463-48f3-be58-7668df524c35 ceph-805428c1-077c-4092-80f5-95b0ac9f5ea5 /dev/sdh1 321 2 1606 172
osd.10 ebfb8caf-a3e6-4715-b992-9ca560104c4e ceph-7e9809bf-c4c0-4686-84f6-4e8639f02dac /dev/sde1 322 2 1606 157
osd.11 7c310379-994d-4faa-9724-1ec1bf6d85bd ceph-3b602d70-99d0-496e-8b96-c34b36d973bc /dev/sdo1 231 1 1604 151
osd.12 cd608ef9-d491-4d09-8f7f-ac82e026b321 ceph-2a8d2275-d307-41ab-9125-17dbe610559a /dev/sdg1 322 2 1606 172
osd.14 782cb3ed-9fcd-40aa-9db3-1cd7babda3fb ceph-9117f02b-c6a0-43a0-ac3f-c0af75381c5f /dev/sdq1 323 1 1606 166
osd.15 77275ae5-d953-44fc-8196-d6b31e005fb3 ceph-c30f789a-3213-49ce-8831-2296e5697119 /dev/sdp1 322 1 1606 168
osd.16 1a325633-209d-4c3a-a89a-c90d6c26688f ceph-397d3bce-9f1a-4e33-9bd0-48f52804a7f6 /dev/sdj1 324 2 2629 264
</code></pre>
<p>最右边的四个数字是：<br />
读取的MB  读取的秒  写入的MB  写入的秒</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ceph的设备关系获取]]></title>
    <link href="zphj1987.com/ceph-de-she-bei-guan-xi-huo-qu.html"/>
    <updated>2022-09-09T10:45:07+08:00</updated>
    <id>zphj1987.com/ceph-de-she-bei-guan-xi-huo-qu.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%9C%80%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求</h2>
<p>因为ceph采用的是lvm管理，磁盘对应关系找起来没有以前方便，所以用一个脚本把当前机器的对应关系列出来</p>
<span id="more"></span><!-- more -->
<h2><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h2>
<pre><code class="language-bash">[root@node235 ceph]# cat get.sh 
#! /bin/bash
IFS=$'\n\n' 
for osd in `ceph osd dump|grep osd|grep -v req|grep -v max|awk '{print ``1,``19}'`
do 

osdnum=`echo  $osd|awk '{print $1}'`
osdid=`echo  $osd|awk '{print $2}'`
vgname=`lvdisplay |grep $osdid -A 1|tail  -n 1|awk '{print $3}'`
pvname=`pvdisplay |grep $vgname -B1|head -n 1|awk '{print $3}'`

echo $osdnum  $osdid  $vgname  $pvname

done

</code></pre>
<h2><a id="%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>效果</h2>
<p>需要用bash命令运行</p>
<pre><code class="language-bash">[root@node235 ceph]# bash get.sh 
osd.0 c40d9963-4894-42bd-a7a8-c9d8c3280e9f ceph-f0f4f8ce-8d02-4111-97bd-fae7ff20a961 /dev/sdd1
osd.1 c4b7f141-51a0-4b97-80b5-e9681025f7db ceph-f786b5a2-82f4-4086-b0d1-7f5e6787c421 /dev/sdc1
osd.2 24f68dd2-5a4f-4b41-8775-ae0211a06e5d ceph-07e22954-93d0-4bb1-9ce3-59485eab1673 /dev/sdi1
osd.3 deed6a2e-456f-40be-bade-07a4b358e2c1 ceph-f1f76e61-d0d6-447b-ac26-a9a2d7fd2d5d /dev/sds1
osd.4 f325a546-a6c7-4610-9916-31062ec6decc ceph-5c1357a5-036a-4f2e-83a8-4463e4349264 /dev/sdf1
osd.5 3790748f-f212-4d46-8b72-b6c9ba007019 ceph-9874a1ac-9163-4936-a2f9-976260f19d6d /dev/sdr1
osd.6 50140786-a01d-47c4-bca4-68ad7730863c ceph-0e4af92c-9766-467c-a7d5-db4435aadd6b /dev/sdk1
osd.7 5e56f9a0-7637-477a-95cf-b995987e6270 ceph-c0de6d4b-1907-49d7-aa9b-194ccbc72465 /dev/sdb1
osd.8 261ea9d8-581b-42ec-9493-1df7b74394b7 ceph-54946fde-edc4-4cf1-b59a-375d69bfff7a /dev/sdm1
osd.9 a4212438-e463-48f3-be58-7668df524c35 ceph-805428c1-077c-4092-80f5-95b0ac9f5ea5 /dev/sdh1
osd.10 ebfb8caf-a3e6-4715-b992-9ca560104c4e ceph-7e9809bf-c4c0-4686-84f6-4e8639f02dac /dev/sde1
osd.11 7c310379-994d-4faa-9724-1ec1bf6d85bd ceph-3b602d70-99d0-496e-8b96-c34b36d973bc /dev/sdo1
osd.12 cd608ef9-d491-4d09-8f7f-ac82e026b321 ceph-2a8d2275-d307-41ab-9125-17dbe610559a /dev/sdg1
osd.14 782cb3ed-9fcd-40aa-9db3-1cd7babda3fb ceph-9117f02b-c6a0-43a0-ac3f-c0af75381c5f /dev/sdq1
osd.15 77275ae5-d953-44fc-8196-d6b31e005fb3 ceph-c30f789a-3213-49ce-8831-2296e5697119 /dev/sdp1
osd.16 1a325633-209d-4c3a-a89a-c90d6c26688f ceph-397d3bce-9f1a-4e33-9bd0-48f52804a7f6 /dev/sdj1
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ceph编译打包中断继续]]></title>
    <link href="zphj1987.com/ceph-bian-yi-da-bao-zhong-duan.html"/>
    <updated>2022-08-30T11:19:36+08:00</updated>
    <id>zphj1987.com/ceph-bian-yi-da-bao-zhong-duan.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%9C%80%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求</h2>
<p>使用rpmbuild打包的时候，如果编译了很久，中间突然出问题，需要从头来处理，这个地方如果有多个错误需要处理的话，每次从头开始就比较浪费时间，我们可以让rpmbuild打包不去删除编译好的包，直接继续</p>
<span id="more"></span><!-- more -->
<h2><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h2>
<p>修改ceph.spec脚本</p>
<pre><code class="language-bash">[root@vcluster ceph]# rpmbuild -bb ceph.spec
修改下ceph.spec文件，可以实现中断继续的功能
%prep
%autosetup -D -p1 -n ceph-12.2.13

#mkdir build
</code></pre>
<p>上面的修改了以后，就可以中断继续编译了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vsphere硬件加速VAAI的实现]]></title>
    <link href="zphj1987.com/vsphere-ying-jian-jia-suvaai-d.html"/>
    <updated>2022-08-24T17:21:35+08:00</updated>
    <id>zphj1987.com/vsphere-ying-jian-jia-suvaai-d.html</id>
    <content type="html"><![CDATA[
<h2><a id="tgtd%E7%9A%84%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>tgtd的支持情况</h2>
<h3><a id="librbd%E6%94%AF%E6%8C%81%E7%9A%84%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>librbd支持的情况</h3>
<p><img src="media/16613328956330/16613278210932.jpg" alt="" /></p>
<span id="more"></span><!-- more -->
<p>从平台上面查询可以看到显示的受支持的</p>
<p>查询</p>
<pre><code class="language-bash">[root@192:~] esxcli storage core device vaai status get
naa.60000000000000000e00000000010000
   VAAI Plugin Name:
   ATS Status: unsupported
   Clone Status: unsupported
   Zero Status: unsupported
   Delete Status: unsupported

naa.60000000000000000e00000000010001
   VAAI Plugin Name:
   ATS Status: supported
   Clone Status: unsupported
   Zero Status: supported
   Delete Status: unsupported
[root@192:~] esxcli storage core device list -d naa.60000000000000000e00000000010001|grep VAAI
   VAAI Status: supported   
</code></pre>
<p>查询支持情况</p>
<p>可以看到四项里面支持两项</p>
<h3><a id="krbd%E7%9A%84%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>krbd的支持情况</h3>
<pre><code class="language-bash">[root@192:~] esxcli storage core device vaai status get
naa.60000000000000000e00000000010000
   VAAI Plugin Name:
   ATS Status: unsupported
   Clone Status: unsupported
   Zero Status: unsupported
   Delete Status: unsupported

naa.60000000000000000e00000000010001
   VAAI Plugin Name:
   ATS Status: supported
   Clone Status: unsupported
   Zero Status: supported
   Delete Status: unsupported
[root@192:~] esxcli storage core device list -d naa.60000000000000000e00000000010001|grep VAAI
   VAAI Status: supported
</code></pre>
<p>可以看到四项里面支持两项</p>
<p>krbd和librbd支持的情况一样</p>
<h2><a id="lio%E7%9A%84%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LIO的支持情况</h2>
<pre><code class="language-bash">[root@192:~] esxcli storage core device vaai status get
mpx.vmhba64:C0:T0:L0
   VAAI Plugin Name:
   ATS Status: unsupported
   Clone Status: unsupported
   Zero Status: unsupported
   Delete Status: unsupported

naa.6001405c6758535437b4da58d6f20420
   VAAI Plugin Name:
   ATS Status: supported
   Clone Status: supported
   Zero Status: supported
   Delete Status: unsupported
[root@192:~] esxcli storage core device list -d naa.6001405c6758535437b4da58d6f20420|grep VAAI
   VAAI Status: supported
</code></pre>
<p>默认支持三项，有一项不支持</p>
<pre><code class="language-bash">[root@lab103 ~]# targetcli /backstores/block/disk01/ get attribute emulate_3pc
emulate_3pc=1
[root@lab103 ~]# targetcli /backstores/block/disk01/ get attribute emulate_tpu
emulate_tpu=0
[root@lab103 ~]# targetcli /backstores/block/disk01/ get attribute emulate_caw
emulate_caw=1
</code></pre>
<p>VAAI相关的支持对应到上面的三个参数，默认开启了两个，有一个discard相关的默认关闭了</p>
<p>开启Delete Status支持</p>
<pre><code class="language-bash">[root@lab103 ~]# targetcli /backstores/block/disk01/ set attribute emulate_tpu=1
Parameter emulate_tpu is now '1'.
[root@lab103 ~]# targetcli / saveconfig
Configuration saved to /etc/target/saveconfig.json
</code></pre>
<p>要断开iscsi再重连一下</p>
<pre><code class="language-bash">[root@192:~] esxcli storage core device vaai status get
mpx.vmhba64:C0:T0:L0
   VAAI Plugin Name:
   ATS Status: unsupported
   Clone Status: unsupported
   Zero Status: unsupported
   Delete Status: unsupported

naa.6001405c6758535437b4da58d6f20420
   VAAI Plugin Name:
   ATS Status: supported
   Clone Status: supported
   Zero Status: supported
   Delete Status: supported
[root@192:~] esxcli storage core device list -d naa.6001405c6758535437b4da58d6f20420|grep VAAI
   VAAI Status: supported
</code></pre>
<p>从上面的查询可以看到LIO能够做到所有的VAAI功能的全支持</p>
<h2><a id="scst%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SCST支持情况</h2>
<h3><a id="blockio%E6%A8%A1%E5%BC%8F%E5%85%A8%E6%94%AF%E6%8C%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>blockio模式全支持</h3>
<pre><code class="language-bash">[root@192:~] esxcli storage core device vaai status get
eui.3237636464633731
   VAAI Plugin Name:
   ATS Status: supported
   Clone Status: supported
   Zero Status: supported
   Delete Status: supported

mpx.vmhba64:C0:T0:L0
   VAAI Plugin Name:
   ATS Status: unsupported
   Clone Status: unsupported
   Zero Status: unsupported
   Delete Status: unsupported

mpx.vmhba0:C0:T0:L0
   VAAI Plugin Name:
   ATS Status: unsupported
   Clone Status: unsupported
   Zero Status: unsupported
   Delete Status: unsupported
[root@192:~] esxcli storage core device list -d eui.3237636464633731|grep VAAI
   VAAI Status: supported
</code></pre>
<h3><a id="fileio%E6%A8%A1%E5%BC%8F%E4%B8%8D%E6%94%AF%E6%8C%81delete-status" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>fileio模式不支持Delete Status</h3>
<pre><code class="language-bash">[root@192:~] esxcli storage core device vaai status get
eui.3237636464633731
   VAAI Plugin Name:
   ATS Status: supported
   Clone Status: supported
   Zero Status: supported
   Delete Status: unsupported
</code></pre>
<h2><a id="%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简单的判断方法</h2>
<p>linux连接iscsi磁盘，看盘是否支持discard<br />
配置的fileio模式如下</p>
<pre><code class="language-bash">[root@lab101 ~]# lsblk /dev/sdc  --discard
NAME              DISC-ALN DISC-GRAN DISC-MAX DISC-ZERO
sdc                      0        0B       0B         0
└─testcipanpiaoyi        0        0B       0B         0
</code></pre>
<p>配置的block模式如下</p>
<pre><code class="language-bash">[root@lab101 ~]# lsblk /dev/sdc  --discard
NAME              DISC-ALN DISC-GRAN DISC-MAX DISC-ZERO
sdc                      0      512B     256M         1
└─testcipanpiaoyi        0      512B     256M         1
</code></pre>
<h2><a id="%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>支持情况总结</h2>
<table>
<thead>
<tr>
<th>VAAI功能</th>
<th>tgt</th>
<th>SCST</th>
<th>LIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATS</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Clone</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Zero</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Delete</td>
<td>N</td>
<td>Y(default N)</td>
<td>Y</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打包一个支持rbd的tgt]]></title>
    <link href="zphj1987.com/da-bao-yi-ge-zhi-chirbd-detgt.html"/>
    <updated>2022-08-24T17:21:35+08:00</updated>
    <id>zphj1987.com/da-bao-yi-ge-zhi-chirbd-detgt.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>下载源码包</h2>
<p>当前的最新版本到了1.0.84,本篇就以这个举例子</p>
<pre><code class="language-bash">[root@lab103 tgtd]# wget https://github.com/fujita/tgt/archive/refs/tags/v1.0.84.tar.gz
[root@lab103 tgtd]# tar -xvf v1.0.84.tar.gz
[root@lab103 tgtd]# cd tgt-1.0.84/
[root@lab103 tgt-1.0.84]# mv README.md README
[root@lab103 scsi]# cd ../
[root@lab103 scsi]# tar -czvf tgt-1.0.84.tar.gz tgt-1.0.84
</code></pre>
<p>上面有个打包的脚本没处理好，需要改下上面的文件名称,然后压缩成新的包</p>
<span id="more"></span><!-- more -->
<p>安装依赖包</p>
<pre><code class="language-bash">yum install libibverbs-devel librdmacm-devel libaio-devel docbook-style-xsl  systemd-devel glusterfs-api-devel -y
</code></pre>
<p>官方的包路径</p>
<pre><code class="language-bash">https://download-ib01.fedoraproject.org/pub/epel/7/SRPMS/Packages/s/scsi-target-utils-1.0.55-4.el7.src.rpm
</code></pre>
<p>官方的包只做到了1.0.55版本的，我们基于这个版本合入我们的最新版本的</p>
<p>解压源码包</p>
<pre><code class="language-bash">[root@lab103 scsi]# rpm2cpio scsi-target-utils-1.0.55-4.el7.src.rpm |cpio -div
</code></pre>
<p>修改打包的脚本</p>
<pre><code class="language-bash">···
%global with_rbd 1
%global with_glfs 0
···
Name:           scsi-target-utils
Version:        1.0.84
···
#%patch0 -p1
</code></pre>
<p>开启rbd，关闭gluster，去掉patch0</p>
<p>把包放打包路径</p>
<pre><code class="language-bash">[root@lab103 scsi]# cp -ra tgt-1.0.84.tar.gz /root/rpmbuild/SOURCES/
[root@lab103 scsi]# cp -ra * /root/rpmbuild/SOURCES/
</code></pre>
<p>打包</p>
<pre><code class="language-bash">[root@lab103 scsi]# rpmbuild -bb scsi-target-utils.spec
···
Wrote: /root/rpmbuild/RPMS/x86_64/scsi-target-utils-1.0.84-4.el7.x86_64.rpm
Wrote: /root/rpmbuild/RPMS/x86_64/scsi-target-utils-rbd-1.0.84-4.el7.x86_64.rpm
···
</code></pre>
<p>这两个包就是我们需要的包</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iscsi客户端常用操作]]></title>
    <link href="zphj1987.com/iscsi-ke-hu-duan-chang-yong-ca.html"/>
    <updated>2022-08-24T17:21:35+08:00</updated>
    <id>zphj1987.com/iscsi-ke-hu-duan-chang-yong-ca.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>说明</h2>
<p>本篇主要记录iscsi的客户端的一些常用的一些操作</p>
<h2><a id="iscsi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>iscsi服务端常用操作</h2>
<p>删除一个lun</p>
<pre><code class="language-bash">tgtadm --lld iscsi --mode logicalunit --op delete  --tid 2  --lun 1
</code></pre>
<span id="more"></span><!-- more -->
<p>新增一个lun</p>
<pre><code class="language-bash">tgtadm --lld iscsi --mode logicalunit --op new --tid 2 --lun 1 --backing-store rbd/test4M --bstype rbd --blocksize 2048
</code></pre>
<p>更新一个lun</p>
<pre><code class="language-bash">tgtadm --lld iscsi --mode logicalunit --op update --tid 2 --lun 1   --param &quot;lbppbe=0&quot;
</code></pre>
<h2><a id="%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用的操作</h2>
<h3><a id="%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装软件</h3>
<pre><code class="language-bash">yum install iscsi-initiator-utils
</code></pre>
<h3><a id="%E6%9F%A5%E8%AF%A2%E8%BF%9C%E7%AB%AF%E7%9A%84iscsi-target" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查询远端的iscsi target</h3>
<pre><code class="language-bash">iscsiadm -m discovery -t sendtargets -p 66.66.66.189
</code></pre>
<h3><a id="%E7%99%BB%E9%99%86%E6%8C%87%E5%AE%9A%E7%9A%84target" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>登陆指定的target</h3>
<pre><code class="language-bash">iscsiadm -m node -T iqn.vcluster.com:target01 -p 66.66.66.189 -l
</code></pre>
<h3><a id="%E6%9F%A5%E8%AF%A2%E5%BD%93%E5%89%8D%E6%9C%BA%E5%99%A8%E8%BF%9E%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查询当前机器连接</h3>
<pre><code class="language-bash">[root@client181 ~]# iscsiadm -m session ls
tcp: [4] 66.66.66.189:3260,1 iqn.vcluster.com:target01 (non-flash)
</code></pre>
<h3><a id="%E6%9F%A5%E8%AF%A2%E5%BD%93%E5%89%8D%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查询当前连接的参数</h3>
<pre><code class="language-bash">iscsiadm -m session -P3|grep -i timeout
    Timeouts:
    Recovery Timeout: 5
    Target Reset Timeout: 30
    LUN Reset Timeout: 30
    Abort Timeout: 15
</code></pre>
<h3><a id="%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>断开连接</h3>
<pre><code class="language-bash">iscsiadm -m node -T iqn.vcluster.com:target01 -p 66.66.66.189 -u
</code></pre>
<h3><a id="%E6%96%AD%E5%BC%80%E6%90%9C%E7%B4%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>断开搜索</h3>
<pre><code class="language-bash">iscsiadm -m discovery -p 66.66.66.189 -o delete
</code></pre>
<blockquote>
<p>注意<br />
<br>iscsi的相关参数是在discovery的时候设置的，所以通过配置文件修改的参数要在下次才能生效，或者通过命令进行在线的更新</p>
</blockquote>
<h3><a id="%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9C%A8%E7%BA%BF%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>服务端在线更新配置</h3>
<pre><code class="language-bash">tgtadm --lld iscsi --op update --mode logicalunit --tid 3  --lun 13 --params lbppbe=0
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下三种配置iscsi的方法]]></title>
    <link href="zphj1987.com/linux-xia-san-zhong-pei-zhiisc.html"/>
    <updated>2022-08-24T17:21:35+08:00</updated>
    <id>zphj1987.com/linux-xia-san-zhong-pei-zhiisc.html</id>
    <content type="html"><![CDATA[
<p>linux下面配置iscsi有多种方法，用户态的有tgt，内核态的有scst和lio，如果只是普通的使用来说，没有太大的区别，对于某些特殊的场景就存在区别了</p>
<p>比如tgt不支持pacemaker里面的 Persistent (SCSI-3) Reservations，而scst支持<br />
tgt不支持vmware的vaai的某些属性，而lio支持<br />
比如scst还支持srpt的功能，而tgt也不支持</p>
<p>所以在某些场景下，我们需要根据自己的需要来选择服务，总体上来说iscsi算是一个中间的组件，并不影响数据本身，只是一个对外的服务，满足需求即可</p>
<h2><a id="tgt%E7%9A%84%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>tgt的配置</h2>
<span id="more"></span><!-- more -->
<p>因为tgt是支持librbd的，也是支持krbd的，所以这个地方存在两种配置，默认的tgt是不支持rbd的，需要自己重新打包支持开启</p>
<pre><code class="language-bash">[root@lab103 ~]# tgtadm --lld iscsi --mode system --op show | grep rbd
</code></pre>
<p>打包的文档见这里：<a href="mweblib://16613240145984">打包一个支持rbd的tgt</a></p>
<h3><a id="%E5%AE%89%E8%A3%85%E6%89%93%E5%A5%BD%E7%9A%84%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装打好的包</h3>
<pre><code class="language-bash">[root@lab103 ~]# rpm -ivh scsi-target-utils-*
Preparing...                          ################################# [100%]
Updating / installing...
   1:scsi-target-utils-1.0.84-4.el7   ################################# [ 50%]
   2:scsi-target-utils-rbd-1.0.84-4.el################################# [100%]
</code></pre>
<p>检查librdb的支持情况</p>
<pre><code class="language-bash">[root@lab103 ~]# tgtadm --lld iscsi --mode system --op show | grep rbd
    rbd (bsoflags sync:direct)
</code></pre>
<h3><a id="%E6%94%AF%E6%8C%81librbd%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>支持librbd的配置方式</h3>
<p>修改配置文件</p>
<pre><code class="language-bash">[root@lab103 ~]# cat /etc/tgt/conf.d/sample.conf
&lt;target iqn.2022-01.com.example:server.target1&gt;
    bs-type rbd
    backing-store rbd/testrbd
&lt;/target&gt;
</code></pre>
<p>启动服务</p>
<pre><code class="language-bash">[root@lab103 ~]# systemctl start tgtd
</code></pre>
<p>查看生成的服务</p>
<pre><code class="language-bash">[root@lab103 ~]# tgt-admin -s
Target 1: iqn.2022-01.com.example:server.target1
    System information:
        Driver: iscsi
        State: ready
    I_T nexus information:
    LUN information:
        LUN: 0
            Type: controller
            SCSI ID: IET     00010000
            SCSI SN: beaf10
            Size: 0 MB, Block size: 1
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: null
            Backing store path: None
            Backing store flags:
        LUN: 1
            Type: disk
            SCSI ID: IET     00010001
            SCSI SN: beaf11
            Size: 32212 MB, Block size: 512
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: rbd
            Backing store path: rbd/testrbd
            Backing store flags:
    Account information:
    ACL information:
        ALL
</code></pre>
<p>可以看到这里多了个</p>
<pre><code class="language-bash">Backing store type: rbd
Backing store path: rbd/testrbd
</code></pre>
<p>客户端登录后查看磁盘</p>
<pre><code class="language-bash">[root@lab101 ~]# parted -s /dev/sdc print
Error: /dev/sdc: unrecognised disk label
Model: IET VIRTUAL-DISK (scsi)
Disk /dev/sdc: 32.2GB
Sector size (logical/physical): 512B/4194304B
Partition Table: unknown
Disk Flags:
</code></pre>
<p>可以看到物理扇区的大小为4194304B，这个在很多环境，rac，vmware都可能不识别，需要修改扇区的大小，这个是在tgt的配置文件里面控制的</p>
<p>修改配置文件</p>
<pre><code class="language-bash">[root@lab103 ~]# cat /etc/tgt/conf.d/sample.conf
&lt;target iqn.2022-01.com.example:server.target1&gt;
    bs-type rbd
    backing-store rbd/testrbd
    lbppbe 0
&lt;/target&gt;
</code></pre>
<p>这个lbppbe 0就是关键配置，设置以后客户端的连接后看到的磁盘扇区就是512b的了</p>
<pre><code class="language-bash">[root@lab101 ~]# parted -s /dev/sdc print
Error: /dev/sdc: unrecognised disk label
Model: IET VIRTUAL-DISK (scsi)
Disk /dev/sdc: 32.2GB
Sector size (logical/physical): 512B/512B
Partition Table: unknown
Disk Flags:
</code></pre>
<h3><a id="%E6%94%AF%E6%8C%81krbd%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>支持krbd的配置方式</h3>
<p>修改配置文件</p>
<pre><code class="language-bash">&lt;target iqn.2022-01.com.example:server.target1&gt;
    backing-store /dev/rbd/rbd/testrbd
&lt;/target&gt;
</code></pre>
<p>启动服务</p>
<pre><code class="language-bash">[root@lab103 ~]# systemctl start tgtd
</code></pre>
<p>查看生成的服务</p>
<pre><code class="language-bash">[root@lab103 ~]# tgt-admin -s
Target 1: iqn.2022-01.com.example:server.target1
    System information:
        Driver: iscsi
        State: ready
    I_T nexus information:
    LUN information:
        LUN: 0
            Type: controller
            SCSI ID: IET     00010000
            SCSI SN: beaf10
            Size: 0 MB, Block size: 1
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: null
            Backing store path: None
            Backing store flags:
        LUN: 1
            Type: disk
            SCSI ID: IET     00010001
            SCSI SN: beaf11
            Size: 32212 MB, Block size: 512
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: rdwr
            Backing store path: /dev/rbd/rbd/testrbd
            Backing store flags:
    Account information:
    ACL information:
        ALL
</code></pre>
<p>这个地方注意下看下客户端的映射的盘的扇区大小</p>
<pre><code class="language-bash">[root@lab101 ~]# parted -s /dev/sdc print
Error: /dev/sdc: unrecognised disk label
Model: IET VIRTUAL-DISK (scsi)
Disk /dev/sdc: 32.2GB
Sector size (logical/physical): 512B/512B
Partition Table: unknown
Disk Flags:
</code></pre>
<h2><a id="lio%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LIO配置</h2>
<h3><a id="%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用命令行配置</h3>
<p>创建一个block设备</p>
<pre><code class="language-bash">[root@lab103 ~]# targetcli /backstores/block/ create disk01 /dev/rbd/rbd/testrbd
Created block storage object disk01 using /dev/rbd/rbd/testrbd.
</code></pre>
<p>查看当前配置</p>
<pre><code class="language-bash">[root@lab103 ~]# targetcli ls /
o- / ............................................................ [...]
  o- backstores ................................................. [...]
  | o- block ..................................... [Storage Objects: 1]
  | | o- disk01  [/dev/rbd/rbd/testrbd (30.0GiB) write-thru deactivated]
  | |   o- alua ...................................... [ALUA Groups: 1]
  | |     o- default_tg_pt_gp .......... [ALUA state: Active/optimized]
  | o- fileio .................................... [Storage Objects: 0]
  | o- pscsi ..................................... [Storage Objects: 0]
  | o- ramdisk ................................... [Storage Objects: 0]
  o- iscsi ............................................... [Targets: 0]
  o- loopback ............................................ [Targets: 0]
</code></pre>
<p>创建一个target</p>
<pre><code class="language-bash">[root@lab103 ~]# targetcli /iscsi/ create iqn.2022-01.org.linux-iscsi.lab103.x8664:sn.192f7d06da4a
Created target iqn.2022-01.org.linux-iscsi.lab103.x8664:sn.192f7d06da4a.
Created TPG 1.
Global pref auto_add_default_portal=true
Created default portal listening on all IPs (0.0.0.0), port 3260.
</code></pre>
<p>创建一个lun</p>
<pre><code class="language-bash">[root@lab103 ~]# targetcli  /iscsi/iqn.2022-01.org.linux-iscsi.lab103.x8664:sn.192f7d06da4a/tpg1/luns create /backstores/block/disk01
Created LUN 0.
</code></pre>
<p>设置target的属性</p>
<pre><code class="language-bash">[root@lab103 ~]# targetcli  /iscsi/iqn.2022-01.org.linux-iscsi.lab103.x8664:sn.192f7d06da4a/tpg1 set attribute authentication=0 demo_mode_write_protect=0 generate_node_acls=1 cache_dynamic_acls=1
</code></pre>
<p>保存配置文件</p>
<pre><code class="language-bash">[root@lab103 ~]# targetcli /  saveconfig
Last 10 configs saved in /etc/target/backup/.
Configuration saved to /etc/target/saveconfig.json
</code></pre>
<p>启动target</p>
<pre><code class="language-bash">[root@lab103 ~]# systemctl start target
</code></pre>
<h2><a id="scst%E7%9A%84%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>scst的配置</h2>
<p>配置fileio模式</p>
<pre><code class="language-bash">[root@lab103 ~]# cat /etc/scst.conf
HANDLER vdisk_fileio {
    DEVICE disk01 {
        filename /dev/rbd/rbd/testrbd
        nv_cache 1
    }
}

TARGET_DRIVER iscsi {
    enabled 1
    TARGET iqn.2022-05.net.vlnb:tgt {
        LUN 0 disk01
        enabled 1
    }
}
</code></pre>
<p>配置blockio模式</p>
<pre><code class="language-bash">[root@lab103 ~]# cat /etc/scst.conf
HANDLER vdisk_blockio {
    DEVICE disk01 {
        filename /dev/rbd/rbd/testrbd
        nv_cache 1
    }
}

TARGET_DRIVER iscsi {
    enabled 1
    TARGET iqn.2022-05.net.vlnb:tgt {
        LUN 0 disk01
        enabled 1
    }
}
</code></pre>
<p>启动服务</p>
<pre><code class="language-bash">[root@lab103 ~]# systemctl start scst
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[局域网内的文件传输]]></title>
    <link href="zphj1987.com/ju-yu-wang-nei-de-wen-jian-chu.html"/>
    <updated>2022-08-23T15:38:04+08:00</updated>
    <id>zphj1987.com/ju-yu-wang-nei-de-wen-jian-chu.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%9C%80%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求</h2>
<p>局域网内的文件传输，使用QQ或者其它网盘什么的，超大文件很容易传输失败，所以可以通过架设http传输服务器的方式进行处理</p>
<p>同样的也可以在有公网IP的服务器上面搭建服务</p>
<h2><a id="%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>搭建服务器</h2>
<p>这个服务器可以在windows或者linux中转服务器都行</p>
<span id="more"></span><!-- more -->
<h3><a id="%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>下载软件服务</h3>
<blockquote>
<p><a href="https://github.com/dutchcoders/transfer.sh">https://github.com/dutchcoders/transfer.sh</a></p>
</blockquote>
<h3><a id="%E5%90%AF%E5%8A%A8http%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>启动http服务</h3>
<pre><code class="language-bash"> .\transfersh-v1.4.0-windows-amd64.exe --provider=local --listener :8080 --temp-path=.\local --basedir=.\local
</code></pre>
<p>这个在windows或者linux上面都行</p>
<h2><a id="%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>访问服务</h2>
<p>通过手机或者另外的客户端直接访问上面的地址端口，然后上传文件即可</p>
<p><img src="media/16612402845294/16612405489519.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何获取cubefs的master的信息]]></title>
    <link href="zphj1987.com/16608989078869.html"/>
    <updated>2022-08-19T16:48:27+08:00</updated>
    <id>zphj1987.com/16608989078869.html</id>
    <content type="html"><![CDATA[
<p>背景<br />
最近关注到一套全新的分布式文件系统cubefs，这个之前的名称是chubaofs，看github上面应该有做切换了一段时间，但是不清楚什么原因,文档和包切换的还不是很彻底</p>
<p>所以在使用过程中需要注意下，注意下版本选择，这个在后面的文档里面再单独的说下这个问题</p>
<p>这个分布式文件系统跟ceph类似，也是采用了管理节点的角色，本篇就是讲如何获取这个管理节点的信息的，从官方的指导文档看，这块讲的还是不够详细</p>
<span id="more"></span><!-- more -->
<p>在github的issue里面已经提了一些咨询的，看下官方后面是否会补充，如果没有处理的，这边应该会基于我自己的经验做一些相关的说明</p>
<p>本篇就是基于这个背景写下的第一篇相关的文章，从开源存储来看，我们自己真正完全开源并且持续维护的软件并不是很多，网易数帆有Curve分布式存储开源，还有个juicefs是可以面向公网把对象转文件的，这个cubefs最开始应该是jd开源出来的，现在看是oppo在维护，大厂下台来开源，品质上可能有一定的保证，这个说可能而不是一定的原因是，本身的开发人员的流动性的可能比国外的要大,再一个这一套是不是对企业本身能够存在收益</p>
<p>这些开源系统的背景大多是目前的开源的存储已经满足不了当前的业务场景的需求，所以需要重新造一套，而开源，可以提升影响力，并且还能让更多人参与进来，用的人多，自然发现的问题越快，越多，而参与的人多，软件的健壮性也会越来越高，当然个人觉得开源软件一个重要的点是可持续性，之前的大厂也开源了很多东西，后面就慢慢不维护了，可能KPI的影响比较大，或者动力不足，希望这个系统能够更长久一些</p>
<h2><a id="%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题来源</h2>
<p>在系统里面做操作，应该是有个默认的习惯的，我们做的任何一个操作，应该是需要有反馈的，不管是失败还是成功，常规的软件基本离不开增删改查这几个操作的</p>
<p>那么这个软件的第一步就是部署的管理节点，问题就是来源于这里，我部署了三个节点，但是我想去查询我部署了哪三个节点，这块不清楚是不是我没找到方法，在文档里面是并没有看到相关的信息，所以在摸索了一番后，终于找到了查询的方法,这里同样提一点，好的软件设计应该是，同时两个人在同一个环境下面操作，A用户在B用户不看的情况下操作一个事情，A用户不告诉B用户具体的信息，B用户能够查到A用户的操作，这个说起来很拗口，我们就以这个举例子</p>
<ul>
<li>A用户增加了三个master节点，101，102，103</li>
<li>A告诉B，我在101上面操作加了三个master节点</li>
<li>B能够在A不提供更多信息的情况下，以最快的速度查询到加的哪些节点</li>
</ul>
<p>这个在gluster里面就是gluster peer status</p>
<p>在ceph里面就是ceph mon dump或者ceph -s</p>
<p>在弄清楚这个问题的过程中，还新学习到了一些东西</p>
<h2><a id="%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查询的方法</h2>
<h3><a id="%E6%90%AD%E5%BB%BAconsole%E5%B9%B3%E5%8F%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>搭建console平台</h3>
<p>这个搭建过程就不说了，官方文档就有，这个使用的是老的2.2.2版本，新的改名字后的2.2.2版本的包没放对，也是提交了bug，等官方修复</p>
<p>这个登录的地方的默认密码硬编码不是很习惯，至少我需要找地方去看这个密码，并且可能会变的</p>
<p>默认用户名密码是</p>
<pre><code class="language-bash">root
ChubaoFSRoot
</code></pre>
<p>后面版本可能改成CubeFSRoot，这个就是这种可能变的情况，可以有更好的办法处理</p>
<p>比较通用的做法</p>
<ul>
<li>沿用操作系统的用户-这个是红帽官方web管理平台的做法（cockpit）</li>
<li>类似minio去采用环境变量，或者配置文件，在启动的时候进行一个设置</li>
<li>类似mysql那种通过命令行去设置，生成一个加密后的密码记录，然后也方便忘记的时候修改,重设密码</li>
<li>或者类似linux的密码逻辑，第一次启动页面设置一个密码，在本地生成加密的密码文件，需要修改密码删掉加密的文件</li>
</ul>
<p>至少有这四种比较灵活的处理登录密码的方法,这块看后期是否会优化下，或者开发者本身觉得这个没多大问题</p>
<p>这里还是自我提问几个问题</p>
<ul>
<li>从什么途径获取(设置)密码</li>
<li>怎么修改密码</li>
<li>忘记了密码无法登录怎么修改密码</li>
</ul>
<h3><a id="%E8%8E%B7%E5%8F%96token" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取token</h3>
<p>这里我们需要登录，登录的时候会跳转，但是我们想获取到这个请求的发送方式，那么就需要设置记录日志<br />
<img src="media/16608989078869/16608992689095.jpg" alt="" /></p>
<p>按F12进入调试模式，有个保留日志的选项，勾选上</p>
<p><img src="media/16608989078869/16608993444981.jpg" alt="" /></p>
<p>在网络tab页里面找到第一个post的请求login，这个从右边可以看到请求类型是post的</p>
<p><img src="media/16608989078869/16608993725538.jpg" alt="" /></p>
<p>tab页里面有个载荷的，这个地方应该是请求的内容</p>
<pre><code class="language-bash">{&quot;operationName&quot;:&quot;Login&quot;,&quot;variables&quot;:{&quot;userID&quot;:&quot;root&quot;,&quot;password&quot;:&quot;082c2c44e2bfae761275e7e2f71d8771b276b32a&quot;},&quot;query&quot;:&quot;query Login($userID: String, $password: String) {\n  login(userID: $userID, password: $password) {\n    token\n    userID\n    __typename\n  }\n}\n&quot;}
</code></pre>
<p>这个是个json的，后面我们会用到,上面是带了用户名密码信息的，这个后面的password应该是处理过的不明文发送的，所以这个记住就行，根据你的密码的固定值的</p>
<p><img src="media/16608989078869/16608993944875.jpg" alt="" /></p>
<pre><code class="language-bash">{&quot;data&quot;:{&quot;login&quot;:{&quot;__typename&quot;:&quot;UserToken&quot;,&quot;token&quot;:&quot;2990b09c-21be-40b5-bc86-802663cf0751&quot;,&quot;userID&quot;:&quot;root&quot;}}}
</code></pre>
<p>这样就拿到了token</p>
<h2><a id="%E8%8E%B7%E5%8F%96master%E7%9A%84%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取master的信息</h2>
<p><img src="media/16608989078869/16608994294713.jpg" alt="" /></p>
<p>可以看到是对着<a href="http://192.168.0.101/api/cluster%E5%9C%B0%E5%9D%80%E5%8F%91%E9%80%81%E7%9A%84POST%E8%AF%B7%E6%B1%82">http://192.168.0.101/api/cluster地址发送的POST请求</a></p>
<p><img src="media/16608989078869/16608994379386.jpg" alt="" /></p>
<p>请求的内容如下</p>
<pre><code class="language-bash">{&quot;operationName&quot;:null,&quot;variables&quot;:{&quot;num&quot;:10000},&quot;query&quot;:&quot;{\n  clusterView {\n    name\n    volumeCount\n    __typename\n  }\n  dataNodeList {\n    addr\n    __typename\n  }\n  metaNodeList {\n    addr\n    __typename\n  }\n  masterList {\n    addr\n    __typename\n  }\n}\n&quot;}
</code></pre>
<p><img src="media/16608989078869/16608994511876.jpg" alt="" /></p>
<p>响应的内容如下:</p>
<pre><code class="language-bash">{&quot;code&quot;:200,&quot;data&quot;:{&quot;clusterView&quot;:{&quot;__typename&quot;:&quot;ClusterView&quot;,&quot;name&quot;:&quot;chubaofs01&quot;,&quot;volumeCount&quot;:0},&quot;dataNodeList&quot;:[],&quot;masterList&quot;:[{&quot;__typename&quot;:&quot;MasterInfo&quot;,&quot;addr&quot;:&quot;192.168.0.101&quot;},{&quot;__typename&quot;:&quot;MasterInfo&quot;,&quot;addr&quot;:&quot;192.168.0.102&quot;},{&quot;__typename&quot;:&quot;MasterInfo&quot;,&quot;addr&quot;:&quot;192.168.0.103&quot;}],&quot;metaNodeList&quot;:[]},&quot;errors&quot;:null}
</code></pre>
<p>到这里我们就通过管理平台拿到master节点的信息，这里是通过graphql master api获取的信息</p>
<blockquote>
<p><a href="https://github.com/cubefs/cubefs/blob/master/proto/admin_proto.go">https://github.com/cubefs/cubefs/blob/master/proto/admin_proto.go</a></p>
</blockquote>
<pre><code class="language-bash">//graphql master api
    AdminClusterAPI = &quot;/api/cluster&quot;
    AdminUserAPI    = &quot;/api/user&quot;
    AdminVolumeAPI  = &quot;/api/volume&quot;
</code></pre>
<p>这个可以自己了解下graphql是什么，这个跟之前的restful的api的最大区别是地址固定，可以通过一个固定的地址获取到不同的信息，把更多的解析工作放到后台了，这里知道是这个就行</p>
<p>我们梳理下流程：</p>
<ul>
<li>获取token</li>
<li>拿着token去对着api发送信息</li>
<li>返回信息，拿到需要的信息</li>
</ul>
<h2><a id="%E4%BD%BF%E7%94%A8postman%E8%B7%91%E4%B8%8B%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用POSTMAN跑下上面的流程</h2>
<h3><a id="postman%E8%8E%B7%E5%8F%96token" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>POSTMAN获取token</h3>
<p><img src="media/16608989078869/16608995047551.jpg" alt="" /></p>
<p>对着<a href="http://192.168.0.101/login%E5%8F%91%E9%80%81post%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%86%85%E5%AE%B9%E4%B8%BA(%E4%B8%8A%E9%9D%A2chrome%E9%87%8C%E9%9D%A2%E6%8A%93%E7%9A%84)">http://192.168.0.101/login发送post请求，内容为(上面chrome里面抓的)</a>:</p>
<pre><code class="language-bash">{&quot;operationName&quot;:&quot;Login&quot;,&quot;variables&quot;:{&quot;userID&quot;:&quot;root&quot;,&quot;password&quot;:&quot;082c2c44e2bfae761275e7e2f71d8771b276b32a&quot;},&quot;query&quot;:&quot;query Login($userID: String, $password: String) {\n  login(userID: $userID, password: $password) {\n    token\n    userID\n    __typename\n  }\n}\n&quot;}
</code></pre>
<p>得到了token:379637f5-0540-4695-b167-75abf7c81074</p>
<p>这个记住就行</p>
<h3><a id="postman%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>POSTMAN获取信息</h3>
<p><img src="media/16608989078869/16608995323650.jpg" alt="" /></p>
<p>可以看到提示的是没有认证的相关的信息</p>
<p>我们加入认证的信息，在oauth2.0里面添加，注意保持prefix为空，填写上获取到的token的信息<br />
<img src="media/16608989078869/16608995419651.jpg" alt="" /></p>
<p><img src="media/16608989078869/16608995489147.jpg" alt="" /></p>
<p>直接发送的话会提示上面的信息</p>
<pre><code class="language-bash">{
    &quot;errors&quot;: [
        &quot;{\&quot;message\&quot;:\&quot;EOF\&quot;,\&quot;code\&quot;:500}&quot;
    ]
}
</code></pre>
<p>这个是因为没有把请求放进去，我们放入请求</p>
<pre><code class="language-bash">{&quot;operationName&quot;:null,&quot;variables&quot;:{&quot;num&quot;:10000},&quot;query&quot;:&quot;{\n  clusterView {\n    name\n    volumeCount\n    __typename\n  }\n  dataNodeList {\n    addr\n    __typename\n  }\n  metaNodeList {\n    addr\n    __typename\n  }\n  masterList {\n    addr\n    __typename\n  }\n}\n&quot;}
</code></pre>
<p>再次发送请求<br />
<img src="media/16608989078869/16608995843954.jpg" alt="" /></p>
<p>可以看到得到了我们想要的信息</p>
<h2><a id="%E4%BD%BF%E7%94%A8curl%E5%AE%9E%E7%8E%B0%E6%88%91%E4%BB%AC%E7%9A%84%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用curl实现我们的请求</h2>
<p>上面使用的是postman客户端，而我们可能更多的在命令行下面执行的，所以我们使用curl把上面完整实现一下</p>
<h2><a id="curl%E8%8E%B7%E5%8F%96token" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>curl获取token</h2>
<pre><code class="language-bash">[root@lab101 cli]# cat login.json
{&quot;operationName&quot;:&quot;Login&quot;,&quot;variables&quot;:{&quot;userID&quot;:&quot;root&quot;,&quot;password&quot;:&quot;082c2c44e2bfae761275e7e2f71d8771b276b32a&quot;},&quot;query&quot;:&quot;query Login($userID: String, $password: String) {\n  login(userID: $userID, password: $password) {\n    token\n    userID\n    __typename\n  }\n}\n&quot;}

[root@lab101 cli]# curl -X POST   http://192.168.0.101/login -d &quot;@login.json&quot;
{&quot;data&quot;:{&quot;login&quot;:{&quot;__typename&quot;:&quot;UserToken&quot;,&quot;token&quot;:&quot;7537d007-6598-484e-a08d-95720593b3ec&quot;,&quot;userID&quot;:&quot;root&quot;}}}
</code></pre>
<p>上面的信息还是之前在chrome拿到的那个登录的信息,可以看到我们正确的获取到了token</p>
<p>我们发送请求</p>
<pre><code class="language-bash">[root@lab101 cli]# cat post.json
{&quot;operationName&quot;:null,&quot;variables&quot;:{&quot;num&quot;:10000},&quot;query&quot;:&quot;{\n  clusterView {\n    name\n    volumeCount\n    __typename\n  }\n  dataNodeList {\n    addr\n    __typename\n  }\n  metaNodeList {\n    addr\n    __typename\n  }\n  masterList {\n    addr\n    __typename\n  }\n}\n&quot;}
[root@lab101 cli]# curl -X POST -H &quot;Authorization: 7537d007-6598-484e-a08d-95720593b3ec&quot;  &quot;http://192.168.0.101:17010/api/cluster&quot; -d &quot;@post.json&quot;
{&quot;errors&quot;:[&quot;not found [_user_key] in header&quot;]}
</code></pre>
<p>这个不清楚为什么跟postman相比多了个这个_user_key的提示，我们加上</p>
<pre><code class="language-bash">[root@lab101 cli]# curl -X POST -H &quot;Authorization: 7537d007-6598-484e-a08d-95720593b3ec&quot; -H &quot;_user_key:root&quot;  &quot;http://192.168.0.101:17010/api/cluster&quot; -d &quot;@post.json&quot;
{&quot;data&quot;:{&quot;clusterView&quot;:{&quot;__typename&quot;:&quot;ClusterView&quot;,&quot;name&quot;:&quot;chubaofs01&quot;,&quot;volumeCount&quot;:0},&quot;dataNodeList&quot;:[],&quot;masterList&quot;:[{&quot;__typename&quot;:&quot;MasterInfo&quot;,&quot;addr&quot;:&quot;192.168.0.101&quot;},{&quot;__typename&quot;:&quot;MasterInfo&quot;,&quot;addr&quot;:&quot;192.168.0.102&quot;},{&quot;__typename&quot;:&quot;MasterInfo&quot;,&quot;addr&quot;:&quot;192.168.0.103&quot;}],&quot;metaNodeList&quot;:[]},&quot;errors&quot;:null}
</code></pre>
<p>可以看到，成功获取到这个信息，在这个时候发现了另外一个有趣的事情，我们看下</p>
<pre><code class="language-bash">[root@lab101 cli]# curl -X POST  -H &quot;_user_key:root&quot;  &quot;http://192.168.0.101:17010/api/cluster&quot; -d &quot;@post.json&quot;
{&quot;data&quot;:{&quot;clusterView&quot;:{&quot;__typename&quot;:&quot;ClusterView&quot;,&quot;name&quot;:&quot;chubaofs01&quot;,&quot;volumeCount&quot;:0},&quot;dataNodeList&quot;:[],&quot;masterList&quot;:[{&quot;__typename&quot;:&quot;MasterInfo&quot;,&quot;addr&quot;:&quot;192.168.0.101&quot;},{&quot;__typename&quot;:&quot;MasterInfo&quot;,&quot;addr&quot;:&quot;192.168.0.102&quot;},{&quot;__typename&quot;:&quot;MasterInfo&quot;,&quot;addr&quot;:&quot;192.168.0.103&quot;}],&quot;metaNodeList&quot;:[]},&quot;errors&quot;:null}
</code></pre>
<p>我没有用token居然在curl下也能够获取到这个信息的，但是在postman下面是必须加上的，所以这个是不是存在鉴权漏洞的，因为这个使用的是2.2.2版本的，后面更新下版本再看下,如果确认有问题再向官方提交了,目前确认2.5.2版本还是有这个问题的,已经提交相关问题，等待回复</p>
<p>鉴权问题</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>在尝试获取master信息过程中，学习了一些请求相关的知识，同时也发现了一些可以优化的点，这个先自己记下来就行</p>

]]></content>
  </entry>
  
</feed>
